# Принципы проектирования потоков Akka

>Как указано в предложении, учтите, что API-интерфейс `Akka Streams` полностью отделен от интерфейсов `Reactive Streams`, 
которые представляют собой деталь реализации для того, как передавать потоковые данные между отдельными операторами.

## Что ожидают пользователи Akka Streams?
Акка построена на сознательном решении предложить минимальные и последовательные API-интерфейсы, в отличие от простых 
или интуитивных. Суть заключается в том, что мы предпочитаем ясность вместо магии, и если мы предоставляем 
функцию, то она должна работать всегда, никаких исключений. Другими словами, мы минимизируем количество 
правил, которые пользователь должен изучить, вместо того, чтобы пытаться поддерживать правила близко к тому, что, как 
мы думаем, могут ожидать пользователи.

Из этого следует, что принципы, реализуемые потоками Akka:

* все функции являются явными в API, **без магии**
* **высшая композиционность**: комбинированные фигуры сохраняют функцию каждой части
* **исчерпывающая модель** области обработки распределенных ограниченных потоков

Это означает, что мы предоставляем все инструменты, необходимые для выражения любой топологии обработки потока, 
чтобы мы моделировали все существенные аспекты этого домена (противодавление, буферизация, преобразования, 
восстановление отказа и т.д.) и что независимо от того, что пользователь создает, можно повторно использовать в 
более широкий контекст.

### Akka Streams не отправляет выпущенные элементы потока в хранилище мертвых писем
Одним из важных последствий использования только функций, на которые можно положиться, является ограничение, которое 
потоки Akka не могут гарантировать, что все объекты, отправленные через топологию обработки, будут обработаны. Элементы 
можно отбросить по нескольким причинам:

* простой пользовательский код может потреблять один элемент в операторе `map(...)` и производить его совсем другое в 
качестве результата
* операторы обычного потока отбрасывают элементы намеренно, например ` take/drop/filter/conflate/buffer/`
* сбой потока приведет к потере потока, не дожидаясь завершения обработки, все элементы, которые находятся в процессе, 
будут отброшены
* аннулирование потока будет распространяться вверх по потоку (например, от оператора `take`), ведущее к завершению 
шагов обработки выше по потоку без обработки всех их входов

Это означает, что отправка объектов JVM в поток, который необходимо очистить, потребует от пользователя убедиться, 
что это происходит за пределами объектов Akka Streams (_например, путем их очистки после тайм-аута или когда их 
результаты наблюдаются на выходе потока, или используя другие средства, такие как финализаторы и т. д.)._

### Результирующие ограничения реализации
Композиционная способность предполагает повторное использование потоков частичного потока, что привело нас к поднятому 
подходу к описанию потоков данных как (частичных) графов, которые могут действовать как составные источники, потоки 
(_трубы_) и поглотители (_sink_) данных. Эти строительные блоки должны быть свободно разделяемыми, с возможностью их 
свободного объединения для формирования больших графов. Поэтому представление этих частей должно быть неизменным 
планом, который материализуется на явном шаге, чтобы начать обработку потока. Результирующий механизм обработки потока 
также является неизменным в смысле наличия фиксированной топологии, которая предписывается планом. Динамические сети 
должны быть смоделированы путем явного использования интерфейсов Reactive Streams для подключения разных двигателей вместе.

Процесс материализации часто создает конкретные объекты, которые могут быть полезны для взаимодействия с процессором 
обработки после его запуска, например, для его закрытия или для извлечения показателей. Это означает, что функция 
материализации дает результат, называемый материализованным значением графа.

## Взаимодействие с другими реализациями реактивных потоков
Akka Streams полностью реализует спецификацию Reactive Streams и взаимодействует со всеми другими совместимыми 
реализациями. Мы решили полностью отделить интерфейсы Reactive Streams от API пользовательского уровня, потому что 
считаем их SPI, которые не нацелены на конечных пользователей. Чтобы получить издателя или подписчика из топологии 
потока Akka, необходимо использовать соответствующий элемент **`Sink.asPublisher`** или **`Source.asSubscriber`**.

Все потоковые Процессоры, созданные по умолчанию материализацией потоков Akka, ограничены наличием единого Подписчика, 
дополнительные подписчики будут отклонены. Причиной этого является то, что топологии потоков, описанные с 
использованием нашего DSL, никогда не требуют поведения разветвителя со сторонних компонентов `Publisher`, все 
разветвления выполняются с использованием явных элементов, таких как `Broadcast[T]`.

Это означает, что `Sink.asPublisher(true)` (для поддержки поддержки разветвителя) должен использоваться там, где поведение 
вещания необходимо для взаимодействия с другими реализациями Reactive Streams.

### Обоснование и преимущества от Sink/Source/Flow, которые не распространяются непосредственно на интерфейсы Reactive Streams
Иногда упускается из виду важнейшая информация о реактивных потоках, так это то, что они являются интерфейсом поставщика 
услуг, как подробно объяснено в одном из ранних обсуждений спецификации. Akka Streams был разработан во время разработки 
реактивных потоков, поэтому они оба сильно повлияли друг на друга.

Это может быть интересно узнать, что даже в рамках Reactive Specification типы первоначально пытались скрыть от 
пользователей API издателей, подписчиков и других типов SPI. Хотя, поскольку в некоторых случаях эти внутренние типы 
SPI в конечном итоге оказываются доступными для конечных пользователей стандарта, было принято решение удалить типы API 
и поддерживать только типы SPI, которые являются `Publisher`, `Subscriber`.

Благодаря этим историческим знаниям и контексту о цели стандарта, являясь внутренней деталью совместимых библиотек, мы 
можем с уверенностью сказать, что нельзя сказать, что прямое отношение наследования с этими типами можно рассматривать 
как некоторую форму преимущества или значащий дифференциатор между библиотеками. Скорее, можно увидеть, что 
API-интерфейсы, которые раскрывают эти типы SPI конечным пользователям, случайно вытесняют внутренние детали реализации.

Типы источников, стоков и потоков, которые являются частью потоков Akka, предназначены для предоставления свободного DSL, 
а также для «фабрик» для запуска этих потоков. Их прямыми аналогами в реактивных потоках являются, соответственно, 
издатель, подписчик и процессор. Другими словами, потоки Akka работают на поднятом представлении вычислительного графа, 
который затем материализуется и выполняется в соответствии с правилами реактивных потоков. Это также позволяет Akka 
Streams выполнять оптимизации, такие как конфигурация слияния и диспетчера во время этапа материализации.

Еще один неочевидный выигрыш от скрытия интерфейсов Reactive Streams связан с тем фактом, что `org.reactivestreams.Subscriber` 
(и др.) Теперь включены в Java 9+ и, таким образом, становятся частью самой Java, поэтому библиотеки должны перейти на 
использование `java.util.concurrent.Flow.Subscriber` вместо `org.reactivestreams.Subscriber`. Библиотеки, которые выбрали 
для раскрытия и прямого распространения типов реактивных потоков, теперь будут иметь более жесткое время для адаптации 
типов JDK9 + - все их классы, которые расширяют подписчиков и друзей, необходимо будет скопировать или изменить для 
расширения одного и того же интерфейса, но из другого пакет. В Akka мы просто выставляем новый тип, когда его просят - 
уже поддерживая типы JDK9, со дня выхода JDK9.

Другая, и, возможно, более важная причина для скрытия интерфейсов Reactive streams возвращается к первым точкам этого 
объяснения: факт Reactive Streams является SPI и, и как таковой трудно "получить право" в специальных реализациях. Таким 
образом, Akka Streams обескураживает использование жесткой реализации частей базовой инфраструктуры и предлагает более 
простые, более безопасные по типу и еще более мощные абстракции для пользователей: `GraphStages` и операторы. Разумеется, 
все еще (и легко) можно принимать или получать потоки React Streams (или JDK + Flow) операторов потока с помощью таких 
методов, как `asPublisher` или `fromSubscriber`.

[Подробнее](https://doc.akka.io/docs/akka/current/general/stream/stream-design.html)

[<= содержание](https://github.com/steklopod/Akka-Streams/blob/master/readme.md)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

