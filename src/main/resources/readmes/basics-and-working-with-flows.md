# Основы работы с потоками

>Чтобы использовать потоки Akka, добавьте модуль в свой проект:
```sbtshell
libraryDependencies += "com.typesafe.akka" %% "akka-stream" % "2.5.17"
```

## Вступление
### Основные понятия
**Akka Streams** - это библиотека для обработки и передачи последовательности элементов с использованием ограниченного 
пространства буфера. Последнее свойство - это то, что мы называем ограниченностью, и оно является определяющей чертой 
потоков Акка. Переведенный на повседневные термины, можно выразить цепочку (_или, как мы увидим ниже, графы_) 
обрабатывающих объектов. Каждый из этих объектов выполняется независимо (_и, возможно, одновременно_) от других, но только 
буферизует ограниченное количество элементов в любой момент времени. Это свойство ограниченных буферов является одним 
из отличий от акторской модели, где каждый актор обычно имеет удаляемый почтовый 
ящик. Субъекты обработки Akka Stream ограничили «почтовые ящики», которые не падают.

Прежде чем двигаться дальше, давайте определим базовую терминологию, которая будет использоваться во всей документации:

#### Поток
Активный процесс, который включает в себя перемещение и преобразование данных.
#### Элемент
Элемент представляет собой блок обработки потоков. Все операции преобразуют и передают элементы от восходящего потока 
вниз. Размеры буфера всегда выражаются как количество элементов независимо от фактического размера элементов.
#### Обратное давление
Средство контроля потока, способ для потребителей данных уведомлять производителя об их текущей доступности, эффективно 
замедляя восходящего производителя, чтобы соответствовать их скоростям потребления. В контексте потоков Akka Streams 
давление всегда понимается как неблокирующее и асинхронное.
#### Неблокируемость
Это означает, что определенная операция не препятствует прогрессу вызывающего потока, даже если для завершения 
запрошенной операции требуется много времени.
#### Граф
Описание топологии обработки потока, определяющее пути, через которые элементы должны течь, когда поток работает.

#### Оператор
Общее имя для всех строительных блоков, которые создают граф. Примерами операторов являются `map()`, `filter()`, 
настраиваемые, расширяющие `GraphStages` и соединения графов, такие как `Merge` или `Broadcast`. Полный список встроенных 
операторов смотрите [здесь](https://doc.akka.io/docs/akka/current/stream/operators/index.html).

Когда мы говорим об асинхронном, неблокирующем противодавлении, мы имеем в виду, что операторы, доступные в потоках 
Akka, не будут использовать блокирующие вызовы, а асинхронные сообщения передаются для обмена сообщениями между собой. 
Таким образом, они могут замедлить быстрого продьюсера, не блокируя его поток. Это дружественный к потоку дизайн, поскольку 
объекты, которым нужно ждать (быстрый продюсер, ожидающий медленного потребителя), не будут блокировать поток, но могут 
передать его для дальнейшего использования в базовый пул потоков.

### Определение и запуск потоков
Линейные источники информации могут быть выражены в потоках Akka, используя следующие абстракции:

#### Источник (Source)
Оператор с ровно одним выходом, испускающий элементы данных, когда операторы нисходящего потока готовы их принимать.
#### Сток (Sink)
Оператор с ровно одним входом, запрашивающим и принимающим элементы данных, возможно, замедляет восходящий производитель элементов.
#### Поток (Flow)
Оператор, который имеет ровно один вход и выход, который соединяет его вверх и вниз по потоку, преобразуя проходящие 
через него элементы данных.
#### RunnableGraph
Поток, который имеет оба конца, «прикреплен» к источнику и стоку соответственно и готов к запуску ().
Можно присоединить поток к источнику, в результате чего создается составной источник, а также можно добавить поток в 
раковину, чтобы получить новый приемник. После того как поток будет правильно завершен, имея как источник, так и приемник, 
он будет представлен типом `RunnableGraph`, указывая, что он готов к выполнению.

```scala
val source = Source(1 to 10)
val sink = Sink.fold[Int, Int](0)(_ + _)

// connect the Source to the Sink, obtaining a RunnableGraph
val runnable: RunnableGraph[Future[Int]] = source.toMat(sink)(Keep.right)

// materialize the flow and get the value of the FoldSink
val sum: Future[Int] = runnable.run()
```

После запуска (материализации) `RunnableGraph[T]` мы возвращаем материализованное значение типа `T`. Каждый оператор 
потока может производить материализованное значение, и пользователь обязан объединить их с новым типом. В приведенном 
выше примере мы использовали `toMat`, чтобы указать, что мы хотим преобразовать материализованное значение источника и 
приемника, и мы использовали функцию удобства `Keep.right`, чтобы сказать, что нас интересует только материализованная 
ценность стока.

В нашем примере `FoldSink` материализует значение типа `Future`, которое будет представлять результат процесса сгибания 
по потоку. В общем, поток может выставлять несколько материализованных значений, но довольно часто его интересует только 
значение `Source` или `Sink` в потоке. По этой причине существует удобный метод, называемый `runWith()`, доступный для 
`Sink`, `Source` или `Flow`, для которого требуется, соответственно, поставляемый источник (для запуска `Sink`), `Sink` 
(для запуска источника) или как источник, так и (для того, чтобы запустить `Flow`, поскольку он еще не подключен).

```scala
val source = Source(1 to 10)
val sink = Sink.fold[Int, Int](0)(_ + _)

// materialize the flow, getting the Sinks materialized value
val sum: Future[Int] = source.runWith(sink)
```

Стоит отметить, что поскольку операторы неизменяемы, их соединение возвращает новый оператор вместо изменения 
существующего экземпляра, поэтому при построении длинных потоков не забудьте назначить новое значение переменной или 
запустить ее:
```scala
val source = Source(1 to 10)
source.map(_ ⇒ 0) // has no effect on source, since it's immutable
source.runWith(Sink.fold(0)(_ + _)) // 55

val zeroes = source.map(_ ⇒ 0) // returns new Source[Int], with `map()` appended
zeroes.runWith(Sink.fold(0)(_ + _)) // 0
```

>По умолчанию элементы Akka Streams поддерживают **ровно один** нисходящий оператор. Предоставляя разветвители 
(поддерживающие несколько последующих операторов), явная функция выбора позволяет элементам потока по умолчанию быть 
менее сложными и более эффективными. Кроме того, он обеспечивает большую гибкость в отношении того, как точно 
обрабатывать сценарии многоадресной передачи, предоставляя именованные элементы разветвления, такие как 
широковещательная передача (сигнализирует все элементы нисходящего потока) или баланс (сигнализирует один из 
доступных элементов вниз по потоку).

В приведенном выше примере мы использовали метод `runWith`, который как материализует поток, так и возвращает 
материализованное значение данного приемника или источника.

Поскольку поток может быть материализован несколько раз, материализованное значение также будет вычисляться заново для 
каждой такой материализации, что обычно приводит к возврату различных значений каждый раз. В приведенном ниже примере 
мы создаем два запускаемых материализованных экземпляра потока, которые мы описали в переменной runnable. Обе 
материализации дают нам другое будущее с карты, хотя мы использовали один и тот же приемник для обозначения будущего:

```scala
// connect the Source to the Sink, obtaining a RunnableGraph
val sink = Sink.fold[Int, Int](0)(_ + _)
val runnable: RunnableGraph[Future[Int]] =
  Source(1 to 10).toMat(sink)(Keep.right)

// get the materialized value of the FoldSink
val sum1: Future[Int] = runnable.run()
val sum2: Future[Int] = runnable.run()

// sum1 and sum2 are different Futures!
```

### Определение источников, стоков и потоков
Объекты `Source` и `Sink` определяют различные способы создания источников и поглотителей элементов. В следующих 
примерах показаны некоторые из наиболее полезных конструкций (более подробную информацию см. В документации по API):

```scala
// Создание источника из Iterable
Source(List(1, 2, 3))

// Создание источника из будущего
Source.fromFuture(Future.successful("Hello Streams!"))

// Создаем источник из одного элемента
Source.single("only one element")

// пустой источник
Source.empty

// Sink, который складывается поверх потока и возвращает будущее
// конечного результата как его материализованное значение
Sink.fold[Int, Int](0)(_ + _)

// Sink, который возвращает Будущее как материализованное значение,
// содержащий первый элемент потока
Sink.head

// Sink, который потребляет поток без каких-либо действий с элементами
Sink.ignore

// Sink, который выполняет побочный вызов для каждого элемента потока
Sink.foreach[String](println(_))
```

Существуют различные способы подключения разных частей потока, следующие примеры показывают некоторые из доступных параметров:

```scala
// Явное создание и подключение Source, Sink and Flow
Source(1 to 6).via(Flow[Int].map(_ * 2)).to(Sink.foreach(println(_)))

// Начиная с Source
val source = Source(1 to 6).map(_ * 2)
source.to(Sink.foreach(println(_)))

// Начиная с Sink
val sink: Sink[Int, NotUsed] = Flow[Int].map(_ * 2).to(Sink.foreach(println(_)))
Source(1 to 6).to(sink)

// Трансляция в приемник
val otherSink: Sink[Int, NotUsed] =
  Flow[Int].alsoTo(Sink.foreach(println(_))).to(Sink.ignore)
Source(1 to 6).to(otherSink)
```

#### Нелегальные элементы потока
В соответствии со спецификацией «Реактивные потоки» потоки Akka не позволяют пропускать `null` через поток в качестве 
элемента. Если вы хотите моделировать концепцию отсутствия значения, мы рекомендуем использовать `scala.Option` или 
`scala.util.Either`.

## Обратное давление
Потоки Akka реализуют асинхронный неблокирующий протокол обратного давления, стандартизованный по спецификации 
Reactive Streams, членом которой является Akka.

Пользователю библиотеки не нужно писать какой-либо явный код обработки обратного давления - он встроен и обрабатывается 
автоматически всеми предоставленными операторами Akka Streams. Однако можно добавить явные операторы буфера с переливами, 
которые могут влиять на поведение потока. Это особенно важно в сложных графиках обработки, которые могут содержать даже 
петли (к ним необходимо относиться с особой осторожностью).

Протокол обратного давления определяется с точки зрения количества элементов, которые подписчик ниже по потоку может 
принимать и буферировать, называемый спросом (`demand`). Источник данных, называемый термином «Издатель в реактивных потоках» и 
реализованный как «Источник в потоках Akka», гарантирует, что он никогда не будет выделять больше элементов, чем 
полученный общий спрос для любого данного Абонента.

>Спецификация Reactive Streams определяет ее протокол в терминах Publisher и Subscriber. Эти типы не предназначены для 
API, ориентированного на пользователя, вместо этого они служат в качестве низкоуровневых строительных блоков для различных 
реализаций реактивных потоков.
Akka Streams реализует эти понятия как источник, поток (называемый процессором в реактивных потоках) и приемник, не 
подвергая непосредственно интерфейсам Reactive Streams. 

Режим, в котором работает обратное давление реактивных потоков, может быть разным образом описана как «динамический 
режим push/pull», поскольку он будет переключаться между моделями обратного давления, основанными на push и pull, в 
зависимости от того, как нисходящий поток может справиться с производительностью добычи или не.

Чтобы проиллюстрировать это, давайте рассмотрим обе проблемные ситуации и то, как их обрабатывает протокол обратного давления:

#### Медленный издатель, быстрый подписчик
Это счастливый случай - в этом случае нам не нужно замедлять работу издателя. Однако скорости передачи сигналов редко 
бывают постоянными и могут меняться в любой момент времени, что внезапно заканчивается в ситуации, когда подписчик 
работает медленнее, чем издатель. В целях защиты от этих ситуаций в таких ситуациях должен быть включен протокол 
обратного давления, однако мы не хотим платить высокий штраф за включение этой защитной сети.

Протокол Reactive Streams решает это путем асинхронной передачи сигналов от подписчиков к сигналам запроса издателя `Request(n:Int)`. 
Протокол гарантирует, что издатель никогда не будет сигнализировать больше элементов, чем заявленное требование. Поскольку 
Абонент, однако, в настоящее время работает быстрее, он будет сигнализировать эти сообщения с запросом более высокой 
скоростью (и, возможно, также объединять запрос, запрашивающий несколько элементов в одном сигнале запроса). Это 
означает, что издателю не нужно ждать (быть обратно) с публикацией входящих элементов.

Как мы видим, в этом сценарии мы эффективно работаем в так называемом push-режиме, поскольку издатель может продолжать 
создавать элементы так быстро, как это возможно, так как ожидающий запрос будет восстановлен точно в срок, пока он 
излучает элементы.

#### Быстрый издатель, медленный подписчик
Это тот случай, когда требуется резервное копирование издателя, потому что Подписчик не может справиться со 
скоростью, с которой его восходящий поток хотел бы испускать элементы данных.

Поскольку издателю не разрешено сигнализировать больше элементов, чем ожидающее требование, подаваемое подписчиком, 
он должен будет придерживаться этого противодавления, применяя одну из следующих стратегий:

* не генерировать элементы, если он способен контролировать свою производительность,
* попробуйте буферизировать элементы ограниченным образом, пока не будет сигнализировано больше спроса,
* капли элементов до тех пор, пока не будет сигнализировано больше спроса,
* срывать поток, если не удается применить ни одну из вышеперечисленных стратегий.

Как мы видим, этот сценарий эффективно означает, что Подписчик вытащит элементы из Издателя - этот режим работы 
называется обратным давлением на основе pull.

## Потоковая материализация
При построении потоков и графиков в потоках Акка думают о них как о подготовке плана, плана выполнения. Потоковая 
материализация - это процесс определения потока (RunnableGraph) и выделения всех необходимых ресурсов для его запуска. 
В случае с потоками Akka это часто означает запуск Актеров, которые управляют обработкой, но не ограничиваются этим - 
это может также означать открытие файлов или соединений сокетов и т. Д. - в зависимости от того, что требуется потоку.

Материализация инициируется при так называемых «терминальных операциях». В первую очередь это включает в себя различные 
формы методов `run()` и `runWith()`, определенных в элементах `Source` и `Flow`, а также небольшое количество специальных 
синтаксических сахаров для работы с известными приемниками, такими как `runForeach(el => ...)` (будучи псевдонимом 
`runWith(Sink.foreach(el => ...))` ).

В настоящее время материализация выполняется синхронно на материализующей нити. Фактическая обработка потока 
обрабатывается участниками, запущенными во время материализации потоков, которые будут выполняться в пулах потоков, для 
которых они были настроены для запуска, - по умолчанию для диспетчера, установленного в `MaterializationSettings`, при 
создании `ActorMaterializer`.

>Повторное использование экземпляров операторов линейных вычислений (Source, Sink, Flow) внутри составных графов 
является законным, но материализует этот оператор несколько раз.

### Слияние операторов
По умолчанию потоки Akka будут сливать потоковые операторы. Это означает, что этапы обработки потока или потока могут 
выполняться внутри одного и того же Актера и имеют два следствия:

* передача элементов от одного оператора к другому намного быстрее между плавленными операторами из-за избежания 
асинхронных служебных сообщений;
* операторы с плавным потоком не работают параллельно друг другу, а это означает, что для каждой конденсированной 
части используется только до одного ядра ЦП.

Чтобы обеспечить параллельную обработку, вам нужно будет вставить асинхронные границы вручную в свои потоки и операторы 
путем добавления атрибутов `Attributes.asyncBoundary`, используя метод async для Source, Sink и Flow для операторов, 
которые должны связываться с нисходящим потоком графика в асинхронном режиме.

```scala
Source(List(1, 2, 3))
  .map(_ + 1).async
  .map(_ * 2)
  .to(Sink.ignore)
```

В этом примере мы создаем две области в потоке, которые будут выполняться в одном акторе каждый - если предположить, 
что добавление и умножение целых чисел является чрезвычайно дорогостоящей операцией, это приведет к увеличению 
производительности, поскольку два процессора могут работать параллельно с задачами. Важно отметить, что асинхронные 
границы не являются особыми местами в потоке, где элементы передаются асинхронно (как в других потоковых библиотеках), 
но вместо этого атрибуты всегда работают, добавляя информацию к потоковому графу, который был создан до этого момента:

![alt text](https://github.com/steklopod/Akka-Streams/tree/master/src/main/resources/images/asyncBoundary.png "asyncBoundary")

Это означает, что все, что находится внутри красного пузыря, будет выполняться одним актером и всем, что находится за его 
пределами другим. Эта схема может применяться последовательно, всегда имея одну такую границу, охватывающую предыдущие, 
и все операторы, которые были добавлены после них.

>Без слияния (то есть до версии 2.0-M2) каждый оператор потока имел неявный входной буфер, который содержит несколько 
элементов по соображениям эффективности. Если ваши потоковые графики содержат циклы, то эти буферы, возможно, были 
решающими, чтобы избежать взаимоблокировок. При слиянии этих неявных буферов больше нет, элементы данных передаются 
без буферизации между плавными операторами. В тех случаях, когда требуется буферизация, чтобы позволить потоку 
запускаться вообще, вам нужно будет вставить явные буферы с оператором `.buffer()`, как правило, достаточно буфера 
размера 2, чтобы можно было использовать цикл обратной связи.

### Сочетание материализованных значений
Поскольку каждый оператор в потоках Akka может обеспечить материализованное значение после его материализации, 
необходимо как-то выразить, как эти значения должны быть составлены до конечного значения, когда мы подключаем эти 
операторы вместе. Для этого многие методы операторов имеют варианты, которые принимают дополнительный аргумент - 
функцию, которая будет использоваться для объединения полученных значений. Некоторые примеры использования этих 
комбинаторов проиллюстрированы в примере ниже.

```scala
// Источник, который может быть сигнализирован явно извне
val source: Source[Int, Promise[Option[Int]]] = Source.maybe[Int]

// Поток, который внутренне регулирует элементы к 1/second и возвращает Cancellable
// который может быть использован для отключения потока
val flow: Flow[Int, Int, Cancellable] = throttler

// Sink который возвращает первый элемент потока в будущем
val sink: Sink[Int, Future[Int]] = Sink.head[Int]

// По умолчанию материализованное значение крайней левой ступени сохраняется
val r1: RunnableGraph[Promise[Option[Int]]] = source.via(flow).to(sink)

// Простой выбор материализованных значений с помощью Keep.right
val r2: RunnableGraph[Cancellable] = source.viaMat(flow)(Keep.right).to(sink)
val r3: RunnableGraph[Future[Int]] = source.via(flow).toMat(sink)(Keep.right)

// Использование runWith всегда даст материализованные значения добавленных этапов с помощью runWith()
val r4: Future[Int] = source.via(flow).runWith(sink)
val r5: Promise[Option[Int]] = flow.to(sink).runWith(source)
val r6: (Promise[Option[Int]], Future[Int]) = flow.runWith(source, sink)

// Использование более сложных комбинаций
val r7: RunnableGraph[(Promise[Option[Int]], Cancellable)] =
  source.viaMat(flow)(Keep.both).to(sink)

val r8: RunnableGraph[(Promise[Option[Int]], Future[Int])] =
  source.via(flow).toMat(sink)(Keep.both)

val r9: RunnableGraph[((Promise[Option[Int]], Cancellable), Future[Int])] =
  source.viaMat(flow)(Keep.both).toMat(sink)(Keep.both)

val r10: RunnableGraph[(Cancellable, Future[Int])] =
  source.viaMat(flow)(Keep.right).toMat(sink)(Keep.both)

// Можно также сопоставить материализованные значения. В r9 у нас была
// дважды вложенная пара, но мы хотим сгладить ее
val r11: RunnableGraph[(Promise[Option[Int]], Cancellable, Future[Int])] =
  r9.mapMaterializedValue {
    case ((promise, cancellable), future) ⇒
      (promise, cancellable, future)
  }

// Теперь мы можем использовать сопоставление с образцом, чтобы получить результирующие материализованные значения
val (promise, cancellable, future) = r11.run()

// Вывод типа работает должным образом
promise.success(None)
cancellable.cancel()
future.map(_ + 3)

// Результат r11 также может быть достигнут с помощью Graph API
val r12: RunnableGraph[(Promise[Option[Int]], Cancellable, Future[Int])] =
  RunnableGraph.fromGraph(GraphDSL.create(source, flow, sink)((_, _, _)) { implicit builder ⇒ (src, f, dst) ⇒
    import GraphDSL.Implicits._
    src ~> f ~> dst
    ClosedShape
  })
```

[Подробнее](https://doc.akka.io/docs/akka/current/stream/stream-flows-and-basics.html#stream-materialization)

[<= содержание](https://github.com/steklopod/Akka-Streams/blob/master/readme.md)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

