# Основы работы с потоками

>Чтобы использовать потоки Akka, добавьте модуль в свой проект:
```sbtshell
libraryDependencies += "com.typesafe.akka" %% "akka-stream" % "2.5.17"
```

## Вступление
### Основные понятия
**Akka Streams** - это библиотека для обработки и передачи последовательности элементов с использованием ограниченного 
пространства буфера. Последнее свойство - это то, что мы называем ограниченностью, и оно является определяющей чертой 
потоков Акка. Переведенный на повседневные термины, можно выразить цепочку (_или, как мы увидим ниже, графы_) 
обрабатывающих объектов. Каждый из этих объектов выполняется независимо (_и, возможно, одновременно_) от других, но только 
буферизует ограниченное количество элементов в любой момент времени. Это свойство ограниченных буферов является одним 
из отличий от акторской модели, где каждый актор обычно имеет удаляемый почтовый 
ящик. Субъекты обработки Akka Stream ограничили «почтовые ящики», которые не падают.

Прежде чем двигаться дальше, давайте определим базовую терминологию, которая будет использоваться во всей документации:

#### Поток
Активный процесс, который включает в себя перемещение и преобразование данных.
#### Элемент
Элемент представляет собой блок обработки потоков. Все операции преобразуют и передают элементы от восходящего потока 
вниз. Размеры буфера всегда выражаются как количество элементов независимо от фактического размера элементов.
#### Обратное давление
Средство контроля потока, способ для потребителей данных уведомлять производителя об их текущей доступности, эффективно 
замедляя восходящего производителя, чтобы соответствовать их скоростям потребления. В контексте потоков Akka Streams 
давление всегда понимается как неблокирующее и асинхронное.
#### Неблокируемость
Это означает, что определенная операция не препятствует прогрессу вызывающего потока, даже если для завершения 
запрошенной операции требуется много времени.
#### Граф
Описание топологии обработки потока, определяющее пути, через которые элементы должны течь, когда поток работает.

#### Оператор
Общее имя для всех строительных блоков, которые создают граф. Примерами операторов являются `map()`, `filter()`, 
настраиваемые, расширяющие `GraphStages` и соединения графов, такие как `Merge` или `Broadcast`. Полный список встроенных 
операторов смотрите [здесь](https://doc.akka.io/docs/akka/current/stream/operators/index.html).

Когда мы говорим об асинхронном, неблокирующем противодавлении, мы имеем в виду, что операторы, доступные в потоках 
Akka, не будут использовать блокирующие вызовы, а асинхронные сообщения передаются для обмена сообщениями между собой. 
Таким образом, они могут замедлить быстрого продьюсера, не блокируя его поток. Это дружественный к потоку дизайн, поскольку 
объекты, которым нужно ждать (быстрый продюсер, ожидающий медленного потребителя), не будут блокировать поток, но могут 
передать его для дальнейшего использования в базовый пул потоков.

### Определение и запуск потоков
Линейные источники информации могут быть выражены в потоках Akka, используя следующие абстракции:

#### Источник (Source)
Оператор с ровно одним выходом, испускающий элементы данных, когда операторы нисходящего потока готовы их принимать.
#### Сток (Sink)
Оператор с ровно одним входом, запрашивающим и принимающим элементы данных, возможно, замедляет восходящий производитель элементов.
#### Поток (Flow)
Оператор, который имеет ровно один вход и выход, который соединяет его вверх и вниз по потоку, преобразуя проходящие 
через него элементы данных.
#### RunnableGraph
Поток, который имеет оба конца, «прикреплен» к источнику и стоку соответственно и готов к запуску ().
Можно присоединить поток к источнику, в результате чего создается составной источник, а также можно добавить поток в 
раковину, чтобы получить новый приемник. После того как поток будет правильно завершен, имея как источник, так и приемник, 
он будет представлен типом `RunnableGraph`, указывая, что он готов к выполнению.

```scala
val source = Source(1 to 10)
val sink = Sink.fold[Int, Int](0)(_ + _)

// connect the Source to the Sink, obtaining a RunnableGraph
val runnable: RunnableGraph[Future[Int]] = source.toMat(sink)(Keep.right)

// materialize the flow and get the value of the FoldSink
val sum: Future[Int] = runnable.run()
```

После запуска (материализации) `RunnableGraph[T]` мы возвращаем материализованное значение типа `T`. Каждый оператор 
потока может производить материализованное значение, и пользователь обязан объединить их с новым типом. В приведенном 
выше примере мы использовали `toMat`, чтобы указать, что мы хотим преобразовать материализованное значение источника и 
приемника, и мы использовали функцию удобства `Keep.right`, чтобы сказать, что нас интересует только материализованная 
ценность стока.

В нашем примере `FoldSink` материализует значение типа `Future`, которое будет представлять результат процесса сгибания 
по потоку. В общем, поток может выставлять несколько материализованных значений, но довольно часто его интересует только 
значение `Source` или `Sink` в потоке. По этой причине существует удобный метод, называемый `runWith()`, доступный для 
`Sink`, `Source` или `Flow`, для которого требуется, соответственно, поставляемый источник (для запуска `Sink`), `Sink` 
(для запуска источника) или как источник, так и (для того, чтобы запустить `Flow`, поскольку он еще не подключен).

```scala
val source = Source(1 to 10)
val sink = Sink.fold[Int, Int](0)(_ + _)

// materialize the flow, getting the Sinks materialized value
val sum: Future[Int] = source.runWith(sink)
```

Стоит отметить, что поскольку операторы неизменяемы, их соединение возвращает новый оператор вместо изменения 
существующего экземпляра, поэтому при построении длинных потоков не забудьте назначить новое значение переменной или 
запустить ее:
```scala
val source = Source(1 to 10)
source.map(_ ⇒ 0) // has no effect on source, since it's immutable
source.runWith(Sink.fold(0)(_ + _)) // 55

val zeroes = source.map(_ ⇒ 0) // returns new Source[Int], with `map()` appended
zeroes.runWith(Sink.fold(0)(_ + _)) // 0
```

>По умолчанию элементы Akka Streams поддерживают **ровно один** нисходящий оператор. Предоставляя разветвители 
(поддерживающие несколько последующих операторов), явная функция выбора позволяет элементам потока по умолчанию быть 
менее сложными и более эффективными. Кроме того, он обеспечивает большую гибкость в отношении того, как точно 
обрабатывать сценарии многоадресной передачи, предоставляя именованные элементы разветвления, такие как 
широковещательная передача (сигнализирует все элементы нисходящего потока) или баланс (сигнализирует один из 
доступных элементов вниз по потоку).

В приведенном выше примере мы использовали метод `runWith`, который как материализует поток, так и возвращает 
материализованное значение данного приемника или источника.

Поскольку поток может быть материализован несколько раз, материализованное значение также будет вычисляться заново для 
каждой такой материализации, что обычно приводит к возврату различных значений каждый раз. В приведенном ниже примере 
мы создаем два запускаемых материализованных экземпляра потока, которые мы описали в переменной runnable. Обе 
материализации дают нам другое будущее с карты, хотя мы использовали один и тот же приемник для обозначения будущего:

```scala
// connect the Source to the Sink, obtaining a RunnableGraph
val sink = Sink.fold[Int, Int](0)(_ + _)
val runnable: RunnableGraph[Future[Int]] =
  Source(1 to 10).toMat(sink)(Keep.right)

// get the materialized value of the FoldSink
val sum1: Future[Int] = runnable.run()
val sum2: Future[Int] = runnable.run()

// sum1 and sum2 are different Futures!
```

### Определение источников, стоков и потоков
Объекты `Source` и `Sink` определяют различные способы создания источников и поглотителей элементов. В следующих 
примерах показаны некоторые из наиболее полезных конструкций (более подробную информацию см. В документации по API):

```scala
// Создание источника из Iterable
Source(List(1, 2, 3))

// Создание источника из будущего
Source.fromFuture(Future.successful("Hello Streams!"))

// Создаем источник из одного элемента
Source.single("only one element")

// пустой источник
Source.empty

// Sink, который складывается поверх потока и возвращает будущее
// конечного результата как его материализованное значение
Sink.fold[Int, Int](0)(_ + _)

// Sink, который возвращает Будущее как материализованное значение,
// содержащий первый элемент потока
Sink.head

// Sink, который потребляет поток без каких-либо действий с элементами
Sink.ignore

// Sink, который выполняет побочный вызов для каждого элемента потока
Sink.foreach[String](println(_))
```

Существуют различные способы подключения разных частей потока, следующие примеры показывают некоторые из доступных параметров:

```scala
// Явное создание и подключение Source, Sink and Flow
Source(1 to 6).via(Flow[Int].map(_ * 2)).to(Sink.foreach(println(_)))

// Начиная с Source
val source = Source(1 to 6).map(_ * 2)
source.to(Sink.foreach(println(_)))

// Начиная с Sink
val sink: Sink[Int, NotUsed] = Flow[Int].map(_ * 2).to(Sink.foreach(println(_)))
Source(1 to 6).to(sink)

// Трансляция в приемник
val otherSink: Sink[Int, NotUsed] =
  Flow[Int].alsoTo(Sink.foreach(println(_))).to(Sink.ignore)
Source(1 to 6).to(otherSink)
```

#### Нелегальные элементы потока
В соответствии со спецификацией «Реактивные потоки» потоки Akka не позволяют пропускать `null` через поток в качестве 
элемента. Если вы хотите моделировать концепцию отсутствия значения, мы рекомендуем использовать `scala.Option` или 
`scala.util.Either`.



[<= содержание](https://github.com/steklopod/Akka-Streams/blob/master/readme.md)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

